## Ejercicio 1

```c
int N;
int T;
char* palabra;

void procesoHijo(int pipeAnt, int pipeNext, int ithHijo){
    while(1){
        // leo palabra (me quedo esperando a que me la pasen)
        read(pipeAnt[PIPE_READ], &palabra, sizeof(&palabra));

        // la modifico
        palabra = modificarPalabra(&palabra, ithHijo);

        // se la paso al sgte
        write(pipeNext[PIPE_WRITE], &palabra, sizeof(&palabra));
    }
}

//          hijo0 -> hijo1 -> ... -> hijoN-2 -> hijoN-1
// pipePadre1   pipe0     pipe1           pipeN-2   pipePadre2

int main(){
    pid_t hijos[N];
    int pipes[N-2][2];
    int pipeHijoPrimer[2];
    int pipeHijoUltimo[2];

    // creo pipes entre hijos, son N-1 hijos, hay N-2 entre ellos
    for(int i=0; i<N-2; i++){
        pipe(pipes[i]);
    }

    // creo pipes para hijo0 e hijoN-1 con padre
    pipe(pipeHijoPrimer);
    pipe(pipeHijoUltimo);

    // creo hijos
    for(int i=0; i<N, i++){
        hijos[i] = fork();

        if(hijos[i] < 0) exit(FAILLURE);
        
        if(hijos[i] == 0){
            if(i==0)
                // caso primer hijo, comunica padre a hijo0, hijo0 a hijo1
                procesoHijo(pipeHijoPrimer, pipes[i], i);
            else if(i == N-1)
                // caso ultimo hijo, comunica hijoN-1 a hijoN-1, 
                procesoHijo(pipes[N-2], pipeHijoUltimo, i);
            else
                // caso hijo del medio
                procesoHijo(pipes[i-1], pipes[i], i);
        }
    }

    // ahora le proceso es el sgte: le paso palabra al primer hijo,
    // luego los hijos entre ellos la procesan hasta llegar al ultimo
    // leo la que me pase el ultimo, si es correcta termina,
    // si no, debo seguir, entonces se la paso de nuevo al primer hijo, y sigue...

    while(--T > 0){ // t-1 veces

        // soy padre, le paso palabra a hijo0
        write(pipeHijoPrimer[PIPE_WRITE], &palabra, sizeof(&palabra));

        // hijos procesan palabra...
        // espero a que hijoN-1 me pase la palabra, y leo
        read(pipeHijoUltimo[PIPE_READ], &palabra, sizeof(&palabra));

        if(adivinarWordle(palabra)){
            printf("ganamos :D");
        }
    }
    
    // haya ganado o perdido, los hijos quedaron en un while true, debo matarlos
    for(int i=0; i < N; i++){
        kill(hijos[i], SIGKILL);
    }
    return 0;
}
```


## Ejercicio 2

### Inciso a)

- En t=0, llegan procesos 1 y 2 a la vez, de tiempos 7 y 5 respectivamente. El scheduler setea que deben correrse primero el 2 y luego el 1


```
Diagrama sin tiempo de context switch y sin bloqueos
    ______________________________________________________________________
p:  | 2 |   3   |      2     |        4        |            1            |
    ¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯
t:  0   1       4            8                 14                        21
```

```
Diagrama con tiempo de context switch y sin bloqueos
    ______________________________________________________________________
p:  | 2 |   3   |      2     |        4        |            1            |
    ¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯
t:  0   2       5            9                 15                        22
```

```
Diagrama con tiempo de context switch y con bloqueos
    ______________________________________________________________
p:  | 2 |   3   |      2     |  4   |  1  |  4   |       1       |
    ¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯
t:  0   2       5            9      11    13     15              20
     1/5   3/3      1+4/5      2/6    2/7  2+2B+2/6    2+1+3B+1/7
```

### Inciso b)

Las sumas del numerador son en orden segun pid:  

- $\text{Waiting Time medio} = \frac{(11+2) + (0+3) + (2) + (9+2)}{4} = 7.25$

- $\text{Turnaround medio} = \frac{20 + 9 + 5 + 15}{4} = 12.25$

### Inciso c)

No, no está libre de inanición, ya que si siguen llegando procesos con un tiempo de ejecución más corto (como sucede con el proceso 3), los procesos de mayor tiempo de ejecución pueden sufrir de este problema, quedando últimos en la cola, y teniendo un waiting time cada vez mayor.  